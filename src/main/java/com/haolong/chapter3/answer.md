## 复习题

### 3.1 ～ 3.3

**R1.**
- 由于为每一个运行的进程分配了4字节端口号，在网络层中提供了ip地址, 所以引用层可以提供 1196字节的数据。
- 如果需要进行通讯，让对方的主机可以发送回包，那么需要包含当前的主机进程的端口地址，所以能够发送1192字节数据。整体结构报文为。
**4字节(主机端口) | 4字节(对方主机端口) | data报文段**
- 在网络结构中，不需要在一层中实现重复的功能， 如果网络层提供了报文的完整性，那么运输层不需要提供完整性功能。

**R2.**
- 发件人在信上写上收件人的名字，然后装进信封中。然后交给家庭成员代表送往邮局。
- 不需要，

**R3.**
- y,x

**R4.**
- 在一些对数据可靠性和完整性要求不是很严格的情况下，但是对于速率有要求，可以使用UDP协议进行运行。

**R5.**
- 因为TCP提供了可靠数据传输功能，保证了数据的可靠性。

**R6.**

- 可能，由于计算机网络层由多层结构，UDP本身不能够进行可靠数据传输，但是在应用层，可以进行实现可靠数据传输，保证数据的可靠性。

**R7.**

- 由于UDP是一个二元组进行区分， 如果A和B都用6789发送数据，那么结构为。
A,6789 | B,6789 虽然端口相同，但是源ip为不同。

**R8.**
- 由于TCP是对4元组进行区分, 是的，他们都有相同的80端口，但是有不同的ip地址，他们通过的不是相同的套接字。

### 3.4

**R9.**
- 在rdt(可靠数据协议reliable data transfer protocol),引入序号的作用是能够保证数据是重新传入的数据还是新的报文数据。

**R10.**
- 引入定时器是如果发送线路阻塞导致报文不能够到达需要进行重新发送。

**R11.**
- 仍然是需要的，虽然往返时间的固定的，但是对于数据的可靠性并没有进行保证，在传输的过程中依然会存在数据丢失的情况。所以定时器仍然需要。

**R12.**
- 在GBN协议中，如果发送5个报文，但是第一个报文被毁掉，那么超时之后会进行重新发送,会从第一个分组进行重新发送。
- 没有关系，后续的报文接收之后会返回ack响应。
- 如果在窗口长度为5的情况下，发送第六个分组无法进行发送。

**R13.**
- 在SR协议中，如果第一个报文没有到达，等待超时之后会进行重新发送
- 如果没有收到第一个ack响应，那么会进行重新发送报文
- 在窗口长度为5的情况下，如果第一个报文没有被确认的情况下，则无法发送第六个分组

### 3.5

**R14.**
- 错误， 因为需要进行回包进行确认接收以方便后续数据包的接收
- 错误, rwnd是可以接收窗口的数据大大小，会随着接收缓存的大小而变化，在接收缓存大小满的情况下，返回rwdn为0，而此时，发送端会发送一个字节的报文段。
- 正确
- 错误，会存在溢出情况，在溢出的情况下，进行从头开始进行计算
- 正确
- 错误，还要取决于EstimatedRTT值
- 错误，确认号为43

**R15.**
- 20字节
- 确认号为90

**R16.**
- 用户发送了两个报文段，而服务器返回了一个报文段，

### 3.7

**R17.**
- R/2

**R18.**
- 错误

**R19.**
3个TCP窗口和一个握手

## 习题

**P1.**
- a. 源: x 目的: 23
- b. 源: y 目的: 23
- c. 源: 23 目的: x
- d. 源: 23 目的: y
- e. 可以相同，因为ip地址不同
- f. 不能相同，如果相同，那么属于同一个会话。

**P2.**
- 源端口号: 80 目的端口号: 7532
- B

**P3.**
```
  01010011                  10111001
+ 01100110      ------>   + 01110100   
______________          _______________
  10111001                  00101110  (注意产生回卷+1)
  
  取反码运算
  11010001
  
  note: 在此声明，反码运算和反码标识不是同一个东西，
  例如:10的二进制反码是自己. 而-10的二进制反码却不是
```

因为反码 + 源码 刚好为 11111111， 所以如果校验的时候中间存在0， 那么就知道数据发生错误。
1比特的差错可以检测出来， 但是两个比特就不一定。 例如上面。 第一个改为 0101001 (0), 第三个改为0111010(1)结果是一样的。

**p4.**
- a.
```
    01011100
  + 01100101     -----> 00111110
--------------
    11000001
```

- b.
```
    11011010
  + 01100101    -------> 10111111
--------------
    01000000
```
- c. First byte = 0101(0)100; second byte = 0110(1)101.

**p5.**

- 不能， 因为在这种情况下， 有可能多个比特互换并且能够校验成功。所以并不是一种100%可信的手段。

**p6.**

- 会的， rdt2.1是在信道不会丢包的情况下来进行理论概述。 如果发生丢包事件那么就会进行死锁。双方都在等待中。

**p7.**

- 因为在这个版本中， 发送方发送了一个分组之后， 会切换到下一个状态。如果发送的ACK不是发送方想要的ACK， 那么会自动忽略。

**p8.**

![rdt3.0 接收方状态图](https://github.com/1440530275/computer-network/raw/master/src/java/com/haolong/chapter3/p8.png)

