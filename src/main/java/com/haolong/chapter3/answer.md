## 复习题

### 3.1 ～ 3.3

**R1.**
- 由于为每一个运行的进程分配了4字节端口号，在网络层中提供了ip地址, 所以引用层可以提供 1196字节的数据。
- 如果需要进行通讯，让对方的主机可以发送回包，那么需要包含当前的主机进程的端口地址，所以能够发送1192字节数据。整体结构报文为。
**4字节(主机端口) | 4字节(对方主机端口) | data报文段**
- 在网络结构中，不需要在一层中实现重复的功能， 如果网络层提供了报文的完整性，那么运输层不需要提供完整性功能。

**R2.**
- 发件人在信上写上收件人的名字，然后装进信封中。然后交给家庭成员代表送往邮局。
- 不需要，

**R3.**
- y,x

**R4.**
- 在一些对数据可靠性和完整性要求不是很严格的情况下，但是对于速率有要求，可以使用UDP协议进行运行。

**R5.**
- 因为TCP提供了可靠数据传输功能，保证了数据的可靠性。

**R6.**

- 可能，由于计算机网络层由多层结构，UDP本身不能够进行可靠数据传输，但是在应用层，可以进行实现可靠数据传输，保证数据的可靠性。

**R7.**

- 由于UDP是一个二元组进行区分， 如果A和B都用6789发送数据，那么结构为。
A,6789 | B,6789 虽然端口相同，但是源ip为不同。

**R8.**
- 由于TCP是对4元组进行区分, 是的，他们都有相同的80端口，但是有不同的ip地址，他们通过的不是相同的套接字。

### 3.4

**R9.**
- 在rdt(可靠数据协议reliable data transfer protocol),引入序号的作用是能够保证数据是重新传入的数据还是新的报文数据。

**R10.**
- 引入定时器是如果发送线路阻塞导致报文不能够到达需要进行重新发送。

**R11.**
- 仍然是需要的，虽然往返时间的固定的，但是对于数据的可靠性并没有进行保证，在传输的过程中依然会存在数据丢失的情况。所以定时器仍然需要。

**R12.**
- 在GBN协议中，如果发送5个报文，但是第一个报文被毁掉，那么超时之后会进行重新发送,会从第一个分组进行重新发送。
- 没有关系，后续的报文接收之后会返回ack响应。
- 如果在窗口长度为5的情况下，发送第六个分组无法进行发送。

**R13.**
- 在SR协议中，如果第一个报文没有到达，等待超时之后会进行重新发送
- 如果没有收到第一个ack响应，那么会进行重新发送报文
- 在窗口长度为5的情况下，如果第一个报文没有被确认的情况下，则无法发送第六个分组

### 3.5

**R14.**
- 错误， 因为需要进行回包进行确认接收以方便后续数据包的接收
- 错误, rwnd是可以接收窗口的数据大大小，会随着接收缓存的大小而变化，在接收缓存大小满的情况下，返回rwdn为0，而此时，发送端会发送一个字节的报文段。
- 正确
- 错误，会存在溢出情况，在溢出的情况下，进行从头开始进行计算
- 正确
- 错误，还要取决于EstimatedRTT值
- 错误，确认号为43

**R15.**
- 20字节
- 确认号为90

**R16.**
- 用户发送了两个报文段，而服务器返回了一个报文段，

### 3.7

**R17.**
- R/2

**R18.**
- 错误

**R19.**
3个TCP窗口和一个握手

## 习题

**P1.**
- a. 源: x 目的: 23
- b. 源: y 目的: 23
- c. 源: 23 目的: x
- d. 源: 23 目的: y
- e. 可以相同，因为ip地址不同
- f. 不能相同，如果相同，那么属于同一个会话。

**P2.**
- 源端口号: 80 目的端口号: 7532
- B

**P3.**
```
  01010011                  10111001
+ 01100110      ------>   + 01110100   
______________          _______________
  10111001                  00101110  (注意产生回卷+1)
  
  取反码运算
  11010001
  
  note: 在此声明，反码运算和反码标识不是同一个东西，
  例如:10的二进制反码是自己. 而-10的二进制反码却不是
```

因为反码 + 源码 刚好为 11111111， 所以如果校验的时候中间存在0， 那么就知道数据发生错误。
1比特的差错可以检测出来， 但是两个比特就不一定。 例如上面。 第一个改为 0101001 (0), 第三个改为0111010(1)结果是一样的。

**p4.**
- a.
```
    01011100
  + 01100101     -----> 00111110
--------------
    11000001
```

- b.
```
    11011010
  + 01100101    -------> 10111111
--------------
    01000000
```
- c. First byte = 0101(0)100; second byte = 0110(1)101.

**p5.**

- 不能， 因为在这种情况下， 有可能多个比特互换并且能够校验成功。所以并不是一种100%可信的手段。

**p6.**

- 会的， rdt2.1是在信道不会丢包的情况下来进行理论概述。 如果发生丢包事件那么就会进行死锁。双方都在等待中。

**p7.**

- 因为在这个版本中， 发送方发送了一个分组之后， 会切换到下一个状态。如果发送的ACK不是发送方想要的ACK， 那么会自动忽略。

**p8.**

![rdt3.0 接收方状态图](https://github.com/1440530275/computer-network/blob/master/src/main/java/com/haolong/chapter3/p8.png?raw=true)

**p9.**

![p9答案](https://github.com/1440530275/computer-network/blob/master/src/main/java/com/haolong/chapter3/p9.png?raw=true)

**p10.**

1. 丢包事件 2.数据不正确  (通过超时重新传输进行解决)
2. 顺序不一致 (使用流水线)

**p11.**

会发生死锁, 发送方等待ACK， 而接收方等待数据包

**p12.**

能够照常运行。 当n是无穷的时候， 只能说错误的报文会进行重新发送， 但是具体发送的数据包大小是不确定的。

**p13.**

![网络重排序在比特交替协议中会存在的问题](https://github.com/1440530275/computer-network/blob/master/src/main/java/com/haolong/chapter3/p13.png?raw=true)

**p14.**

如果只是偶尔发送数据， 如果发送方发送第 y 个数据的时候， 数据有问题， 但是接收方并不知情， 因为只有接收方接收到y + 1个分组的时候才知道第 y 个分组有问题。 所以在发送数据量比较小的情况下， 并不会比ack协议更好。<br/>
如果在发送大量数据， 并且丢包率很少的情况下， 那么这种情况下使用nak会比ack要好得多， 因为nak发送的次数会很少。

**p15.**

```math
1500 * 8 = 12000(bit)

2RTT + L/R = 30.012(ms) 

0.95 = \frac{0.012}{30.012}

\frac{0.012 * n}{28.5114}

n = 2375
```

**p16.**

不能增加信道的利用率， 同时发送发批量的数据， ack0 和 ack1 的匹配很有可能匹配到错误的包上面。

**p22.**

a. [k - 4, k + 3]

b. [k - 4, k - 1]

**p23.**

GBN: [1, k]

SR:[k/2, k]

**p24.**

a. 是的， 有可能在前面有发生丢包行为， 然后接收方进行ack返回信息并且要求进行重新传入。

b.是的， 和上一个一样。

c. 是的， 当窗口大小为1的时候， 他们的功能都是等价的。 因为窗口1排除了无序的可能性。所以是一样的。

d. 是的

**p25.**

a. UDP会直接将数据打包给网络层， 而TCP可能会分成多个包进行传输。

b. 首先UDP对比TCP， 因为TCP是有拥塞控制机制， 当网络变得不好的时候， 无法控制发送的速率。 但是UDP没有这样的限制， 当把数据包传输给传输层得时候， UDP会直接打包传送给网络层。

**p26.**

a. `$2^{32}$`

b.
```math
    需要发送的包数量 = \frac{2^{32}}{536} = 8012999
    
    额外字节大小: 8012999 * 66 = 52885734
    
    \frac{(2 ^ {32}) + 52885734}{155 * 10^6} = 249s
```

**p27.**

a. 207, 302, 80

b. 207, 80, 302

c. 127

**p28.**

主机B将rwnd值放入报文中发送给A， 通知B的窗口缓存大小。 当缓存不足时， 将暂停向B发送数据。

**p29.**

a. 方式SYN泛洪攻击

b. 可以， 只要进行3次握手就可以进行创建半开的连接。

c. 不能，因为SYM cookie 根据客户的ip地址和porn

**30.**

a. 如果从无限缓存转换到有限缓存， 会如果传入速率>R/2， 那么会存在缓存满的状态， 会有数据溢出。会发生丢包行为， 从而降低吞吐。

b. 不能增加吞吐量， 只有增加路由器速率或者服务端速率。

**p31.**

```math
    
    EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT
    
    DevRTT = (1 - b) * |SampleRTT - EstimatedRTT|
    
    已知 a = 0.125, b = 0.25, SampleRTT = 106ms, 120ms, 140ms, 90ms, 115ms
    
    累计计算:
    
    TimeoutInterval = 165 ms
    
```

**p33.**

如果 a 向 b 传输报文， 此时a 传送 d1 的时候数据包并且继续向后发送数据包， 但是此时d1数据包因为种种原因超时， a 进行重发， 但是b返回ack给a程序， 该数据包并没有丢失， 但是a以为是这次重发回调的ack， 所以没有加入重传测试。

**p34.**

SendBase - 1 是发送方最后确认报文的位置。 LastByteRcvd是接收主机最后一个字节的编号。

SendBase - 1 <= LastByteRcvd

**p35.**

y 期待收到ACK值的位置。

y - 1 <= LastByteRcvd

**p36.**

可能该包只是失序， 并不是丢失了。

**p37.**

a.

GBN: 9个data 8ACK

SR: 6, 5

TCP: 6, 5

b.

TCP, SR只有超时才能重传

**p38.**

是的， 每个RTT必须大于等于cwnd

**p39.**

如果 in 超过了 R/2, out增加不能超过 R/3. 假设在一个有限缓存的路由中， 伴随的时间的增加，没3次包中就会有一次是重传。并且随着时间增加丢包的几率会增加。

**p40.**

a. 1 ~ 6, 23 ~ 26

b. 6 ~ 16, 17 ~ 22

c. 3个冗余ack

d. 超时检测

e. 32

d. 21

e. 14

h. 拥塞避免

i. ssth = 4, cwnd = 7

j. 24, 27

k. 17 ~ 22

**p42.**

TCP不是停等协议， 所以当有一个超时事件发生的时候， tcp会依然进行发送。所以需要依靠拥塞控制机制。

**p43.**

首先， 因该该条链路不会发生分组丢失和超时发生， 所以不会发生拥塞的情况发生。 并且接收方的缓存足够将整个文件缓存下来， 但是当发送方的缓存用完的时候， 发送方的速率只有 Rbps. 所以TCP用的流量控制。

**p44.**

a. 6RTT

b. (6 + 7 + 8 + 9 + 10 + 11) / 6 = 8.5MSS

**p46.**

a.
```math

    \frac{W * MSS}{RTT} = 10Mbps
    
    \frac{W * 1500 * 8}{0.15} = 10Mbps
    
    \frac{W * 12000}{0.15} = 10000000
    
    \frac{W * 12000}{1500000}
    
    W = 125

```

b. 由于拥塞窗口的大小从W/2到W不等，因此平均窗口大小为0.75W=94（上限为93.75）段。平均吞吐量为94*1500*8/0.15=7.52Mbps。

c. 


